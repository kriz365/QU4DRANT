"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ApiClientError: () => ApiClientError,
  EntityManager: () => EntityManager,
  EntityQuery: () => EntityQuery,
  SuperdevClient: () => SuperdevClient,
  createSuperdevClient: () => createSuperdevClient
});
module.exports = __toCommonJS(index_exports);

// src/auth.ts
var AuthModule = class {
  client;
  options;
  user = null;
  constructor(client, options = {}) {
    this.client = client;
    this.options = {
      loginUrl: `${client.baseUrl}/auth/app-login`,
      tokenStorageKey: "superdev_access_token",
      refreshTokenKey: "superdev_refresh_token",
      ...options
    };
  }
  /**
   * Get the current authentication token
   */
  getToken() {
    if (typeof window === "undefined") {
      return this.client.token;
    }
    return localStorage.getItem(this.options.tokenStorageKey);
  }
  /**
   * Set the authentication token
   */
  setToken(token) {
    if (typeof window === "undefined") {
      this.client.setToken(token);
      return;
    }
    localStorage.setItem(this.options.tokenStorageKey, token);
  }
  /**
   * Clear the authentication token
   */
  clearToken() {
    if (typeof window === "undefined") return;
    localStorage.removeItem(this.options.tokenStorageKey);
    this.user = null;
  }
  /**
   * Redirect to the login page
   */
  login() {
    this.client.redirectToLogin();
  }
  /**
   * Check if the user is authenticated
   */
  async isAuthenticated() {
    try {
      const token = this.getToken();
      if (!token) return false;
      const response = await this.client.request("/auth/verify", {
        headers: { Authorization: `Bearer ${token}` }
      });
      this.user = response;
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Get the current user
   */
  async getUser() {
    if (this.user) return this.user;
    return await this.isAuthenticated() ? this.user : null;
  }
  /**
   * Get the current user's full profile
   */
  async me() {
    const response = await this.client.entity("User").get("me");
    this.user = response;
    return response;
  }
  async list(options) {
    const response = await this.client.entity("User").list(options);
    return response;
  }
  /**
   * Update the current user's profile
   */
  async updateProfile(data) {
    const response = await this.client.entity("User").update("me", data);
    this.user = response;
    return response;
  }
  /**
   * Log the user out
   */
  async logout(redirectToLogin = true) {
    if (typeof window === "undefined") return;
    try {
      this.clearToken();
    } catch (error) {
      console.error("Failed to logout:", error);
    } finally {
      if (redirectToLogin) this.login();
    }
  }
};
function createAuthModule(client, options = {}) {
  return new AuthModule(client, options);
}

// src/integrations.ts
var createIntegrationsModule = (client) => {
  const appId = client.appId;
  return new Proxy(
    {},
    {
      get(_, integrationName) {
        if (typeof integrationName === "string" && integrationName !== "then" && !integrationName.startsWith("_")) {
          return new Proxy(
            {},
            {
              get(_2, methodName) {
                if (typeof methodName === "string" && methodName !== "then" && !methodName.startsWith("_")) {
                  return async (params) => {
                    if (typeof params === "string") {
                      throw new Error(
                        `Integration ${methodName} must receive an object with named parameters`
                      );
                    }
                    let payload = params;
                    let contentType = "application/json";
                    if (params instanceof FormData || Object.values(params).some((p) => p instanceof File)) {
                      const formData = new FormData();
                      for (const key in params) {
                        const value = params[key];
                        if (value instanceof File) {
                          formData.append(key, value, value.name);
                        } else if (typeof value === "object" && value !== null) {
                          formData.append(key, JSON.stringify(value));
                        } else {
                          formData.append(key, value);
                        }
                      }
                      payload = formData;
                      contentType = "multipart/form-data";
                    }
                    let url;
                    switch (integrationName) {
                      case "core":
                        url = `/apps/${appId}/core/${methodName}`;
                        break;
                      default:
                        url = `/apps/${appId}/installed/${integrationName}/${methodName}`;
                    }
                    return client.post(url, payload);
                  };
                }
              }
            }
          );
        }
      }
    }
  );
};

// src/functions.ts
var createFunctionsModule = (client) => {
  const appId = client.appId;
  return new Proxy(
    {},
    {
      get(_, functionName) {
        if (typeof functionName === "string" && functionName !== "then" && !functionName.startsWith("_")) {
          return async (params) => {
            if (typeof params === "string") {
              throw new Error(
                `Function ${functionName} must receive an object with named parameters`
              );
            }
            let payload = params || {};
            let contentType = "application/json";
            if (params && (params instanceof FormData || Object.values(params).some((p) => p instanceof File))) {
              const formData = new FormData();
              for (const key in params) {
                const value = params[key];
                if (value instanceof File) {
                  formData.append(key, value, value.name);
                } else if (typeof value === "object" && value !== null) {
                  formData.append(key, JSON.stringify(value));
                } else {
                  formData.append(key, value);
                }
              }
              payload = formData;
              contentType = "multipart/form-data";
            }
            const url = `/apps/${appId}/functions/${functionName}`;
            return client.post(url, payload);
          };
        }
      }
    }
  );
};

// src/client.ts
var EntityQuery = class {
  constructor(client, entityName, appId) {
    this.client = client;
    this.entityName = entityName;
    this.appId = appId;
  }
  query = {};
  options = {};
  /**
   * Set fields to select (projection)
   */
  select(fields) {
    this.options.fields = fields;
    return this;
  }
  /**
   * Set sort order
   */
  sort(sort) {
    this.options.sort = sort;
    return this;
  }
  /**
   * Set result limit
   */
  limit(limit) {
    this.options.limit = limit;
    return this;
  }
  /**
   * Set number of results to skip (for pagination)
   */
  skip(skip) {
    this.options.skip = skip;
    return this;
  }
  /**
   * Add a where condition
   */
  where(field, value) {
    this.query[field] = value;
    return this;
  }
  /**
   * Add an equals condition
   */
  equals(field, value) {
    return this.where(field, value);
  }
  /**
   * Add a not equals condition
   */
  notEquals(field, value) {
    this.query[field] = { $ne: value };
    return this;
  }
  /**
   * Add a greater than condition
   */
  gt(field, value) {
    this.query[field] = { ...this.query[field], $gt: value };
    return this;
  }
  /**
   * Add a greater than or equal condition
   */
  gte(field, value) {
    this.query[field] = { ...this.query[field], $gte: value };
    return this;
  }
  /**
   * Add a less than condition
   */
  lt(field, value) {
    this.query[field] = { ...this.query[field], $lt: value };
    return this;
  }
  /**
   * Add a less than or equal condition
   */
  lte(field, value) {
    this.query[field] = { ...this.query[field], $lte: value };
    return this;
  }
  /**
   * Add an in condition
   */
  in(field, values) {
    this.query[field] = { $in: values };
    return this;
  }
  /**
   * Add a not in condition
   */
  nin(field, values) {
    this.query[field] = { $nin: values };
    return this;
  }
  /**
   * Execute query and return results
   */
  async exec() {
    const basePath = `/apps/${this.appId}/entities/${this.entityName}`;
    const params = {
      q: JSON.stringify(this.query)
    };
    if (this.options.sort) {
      params.sort = typeof this.options.sort === "string" ? this.options.sort : JSON.stringify(this.options.sort);
    }
    if (this.options.limit) params.limit = this.options.limit;
    if (this.options.skip) params.skip = this.options.skip;
    if (this.options.fields) {
      params.fields = Array.isArray(this.options.fields) ? this.options.fields.join(",") : this.options.fields;
    }
    return this.client.get(basePath, { params });
  }
  /**
   * Count matching documents
   */
  async count() {
    const result = await this.limit(1).exec();
    return result.total;
  }
  /**
   * Get first matching document
   */
  async first() {
    const result = await this.limit(1).exec();
    if (result.data.length > 0) {
      return result.data[0] ?? null;
    }
    return null;
  }
};
var EntityManager = class {
  constructor(client, entityName, appId) {
    this.client = client;
    this.entityName = entityName;
    this.appId = appId;
    this.basePath = `/apps/${appId}/entities/${entityName}`;
  }
  basePath;
  /**
   * Create a new query builder
   */
  query() {
    return new EntityQuery(this.client, this.entityName, this.appId);
  }
  /**
   * Find entities matching query
   */
  find(query, options) {
    const builder = this.query();
    if (query) {
      Object.entries(query).forEach(([key, value]) => {
        builder.where(key, value);
      });
    }
    if (options?.sort) builder.sort(options.sort);
    if (options?.limit) builder.limit(options.limit);
    if (options?.skip) builder.skip(options.skip);
    if (options?.fields) builder.select(options.fields);
    return builder;
  }
  /**
   * Find entities with simpler interface (compatible with previous API)
   */
  async filter(query, sort, limit, skip, fields) {
    return this.find(query, { sort, limit, skip, fields }).exec();
  }
  /**
   * List all entities with optional pagination
   */
  async list(options) {
    return this.find({}, options).exec();
  }
  /**
   * Get entity by ID
   */
  async get(id) {
    return this.client.get(`${this.basePath}/${id}`);
  }
  /**
   * Create new entity
   */
  async create(data) {
    return this.client.post(this.basePath, data);
  }
  /**
   * Update entity by ID
   */
  async update(id, data) {
    return this.client.put(`${this.basePath}/${id}`, data);
  }
  /**
   * Delete entity by ID
   */
  async delete(id) {
    return this.client.delete(`${this.basePath}/${id}`);
  }
  /**
   * Delete multiple entities
   */
  async deleteMany(ids) {
    return this.client.delete(
      this.basePath,
      {
        data: { ids }
      }
    );
  }
  /**
   * Create multiple entities in one request
   */
  async bulkCreate(data) {
    return this.client.post(
      `${this.basePath}/bulk`,
      data
    );
  }
  /**
   * Import entities from a file
   */
  async importEntities(file) {
    const formData = new FormData();
    formData.append("file", file, file.name);
    return this.client.post(
      `${this.basePath}/import`,
      formData,
      {
        headers: { "Content-Type": "multipart/form-data" }
      }
    );
  }
  /**
   * Batch operations for efficiency
   */
  batch() {
    return {
      /**
       * Create multiple entities
       */
      create: (items) => {
        return this.bulkCreate(items);
      },
      /**
       * Update multiple entities
       */
      update: async (updates) => {
        return this.client.put(
          `${this.basePath}/batch`,
          { updates }
        );
      },
      /**
       * Delete multiple entities
       */
      delete: (ids) => {
        return this.deleteMany(ids);
      }
    };
  }
};
var ApiClientError = class extends Error {
  status;
  code;
  data;
  originalError;
  constructor(message, status, code, data, originalError) {
    super(message);
    this.name = "ApiClientError";
    this.status = status;
    this.code = code;
    this.data = data;
    this.originalError = originalError;
  }
};
var SuperdevClient = class {
  token = null;
  options;
  baseUrl;
  appId;
  user = null;
  isInitialized = false;
  entityManagers = /* @__PURE__ */ new Map();
  authPromise = null;
  routeChangeListenersAdded = false;
  /**
   * Create a new Superdev client
   */
  constructor(options = {}) {
    if (!options.appId) {
      throw new Error("[SuperdevClient] appId is required");
    }
    this.options = {
      baseUrl: "https://superdev.build/api",
      requiresAuth: false,
      tokenStorageKey: "superdev_access_token",
      refreshTokenKey: "superdev_refresh_token",
      token: "",
      appId: "",
      loginUrl: "/login",
      ...options
    };
    this.baseUrl = options.baseUrl || "https://superdev.build/api";
    this.appId = options.appId;
    if (typeof window !== "undefined") {
      this.initialize();
      if (this.options.requiresAuth) {
        setTimeout(async () => {
          try {
            if (this.doesCurrentRouteRequireAuth() && !await this.isAuthenticated()) {
              this.redirectToLogin();
            }
          } catch (error) {
            console.error("Authentication check failed:", error);
            this.redirectToLogin();
          }
        }, 0);
      }
    }
  }
  /**
   * Check if a path matches a pattern
   * @param pattern The pattern to match against (e.g., '/users/:id', '/admin/*')
   * @param path The actual path to check
   * @returns Whether the path matches the pattern
   */
  matchPath(pattern, path) {
    const normalizedPattern = pattern.endsWith("/") && pattern.length > 1 ? pattern.slice(0, -1) : pattern;
    const normalizedPath = path.endsWith("/") && path.length > 1 ? path.slice(0, -1) : path;
    if (normalizedPattern === normalizedPath) {
      return true;
    }
    if (normalizedPattern.endsWith("/*")) {
      const basePattern = normalizedPattern.slice(0, -2);
      return normalizedPath === basePattern || normalizedPath.startsWith(`${basePattern}/`);
    }
    if (normalizedPattern.includes(":")) {
      const patternParts = normalizedPattern.split("/");
      const pathParts = normalizedPath.split("/");
      if (patternParts.length !== pathParts.length) {
        return false;
      }
      return patternParts.every((segment, i) => {
        if (segment.startsWith(":")) {
          return true;
        }
        return segment === pathParts[i];
      });
    }
    return false;
  }
  /**
   * Check if the current route requires authentication
   * @returns Whether authentication is required for the current route
   */
  doesCurrentRouteRequireAuth() {
    if (typeof window === "undefined") {
      return false;
    }
    const { requiresAuth } = this.options;
    if (typeof requiresAuth === "boolean") {
      return requiresAuth;
    }
    if (Array.isArray(requiresAuth) && requiresAuth.length > 0) {
      const currentPath = window.location.pathname;
      return requiresAuth.some(
        (pattern) => this.matchPath(pattern, currentPath)
      );
    }
    return false;
  }
  /**
   * Initialize the client
   * - Reads token from storage
   * - Sets up token refresh
   * - Handles redirects for authentication
   */
  async initialize() {
    if (this.isInitialized) return;
    const urlParams = new URLSearchParams(window.location.search);
    const urlToken = urlParams.get("access_token");
    const urlRefreshToken = urlParams.get("refresh_token");
    if (urlToken) {
      this.setToken(urlToken);
      if (urlRefreshToken) {
        this.setRefreshToken(urlRefreshToken);
      }
      urlParams.delete("access_token");
      urlParams.delete("refresh_token");
      const newUrl = window.location.pathname + (urlParams.toString() ? `?${urlParams.toString()}` : "") + window.location.hash;
      window.history.replaceState({}, document.title, newUrl);
      await this.validateToken();
    }
    this.setupRouteChangeListeners();
    this.isInitialized = true;
  }
  /**
   * Setup listeners for route changes in SPAs
   * This allows us to check authentication on client-side navigation
   */
  setupRouteChangeListeners() {
    if (typeof window === "undefined" || this.routeChangeListenersAdded) {
      return;
    }
    const originalPushState = window.history.pushState;
    const originalReplaceState = window.history.replaceState;
    window.history.pushState = (...args) => {
      originalPushState.apply(window.history, args);
      this.handleRouteChange();
    };
    window.history.replaceState = (...args) => {
      originalReplaceState.apply(window.history, args);
      this.handleRouteChange();
    };
    window.addEventListener("popstate", () => {
      this.handleRouteChange();
    });
    window.addEventListener("hashchange", () => {
      this.handleRouteChange();
    });
    this.routeChangeListenersAdded = true;
  }
  /**
   * Handle a detected route change in SPAs
   */
  async handleRouteChange() {
    if (this.doesCurrentRouteRequireAuth()) {
      try {
        if (!await this.isAuthenticated()) {
          this.redirectToLogin();
        }
      } catch (error) {
        console.error("Authentication check failed on route change:", error);
        this.redirectToLogin();
      }
    }
  }
  /**
   * Validate the current token and get user information
   */
  async validateToken() {
    const token = this.getToken();
    if (!token) {
      throw new Error("No token available");
    }
    const response = await fetch(`${this.options.baseUrl}/auth/verify`, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    if (!response.ok) {
      if (response.status === 401) {
        const refreshedUser = await this.refreshToken();
        if (refreshedUser) {
          return refreshedUser;
        }
      }
      throw new Error("Invalid token");
    }
    const data = await response.json();
    if (!data.authenticated || !data.user) {
      throw new Error("Authentication failed");
    }
    this.user = data.user;
    return this.user;
  }
  /**
   * Refresh the authentication token
   */
  async refreshToken() {
    if (typeof window === "undefined") {
      return;
    }
    try {
      const refreshToken = this.getRefreshToken();
      if (!refreshToken) {
        throw new Error("No refresh token to refresh");
      }
      const response = await fetch(
        `${this.options.baseUrl}/auth/${this.options.appId}/refresh-token`,
        {
          headers: {
            Authorization: `Bearer ${refreshToken}`
          }
        }
      );
      if (!response.ok) {
        throw new Error("Token refresh failed");
      }
      const data = await response.json();
      if (!data.success) {
        throw new Error(data.error || "Failed to refresh token");
      }
      this.setToken(data.accessToken);
      this.setRefreshToken(data.refreshToken);
      return await this.validateToken();
    } catch (error) {
      console.error("Error refreshing token:", error);
      if (this.doesCurrentRouteRequireAuth()) {
        this.redirectToLogin();
      }
    }
  }
  /**
   * Get the current authentication token
   */
  getToken() {
    if (typeof window === "undefined") {
      return this.options.token;
    }
    return localStorage.getItem(this.options.tokenStorageKey);
  }
  /**
   * Set the authentication token
   */
  setToken(token) {
    if (typeof window === "undefined") {
      this.options.token = token;
      return;
    }
    localStorage.setItem(this.options.tokenStorageKey, token);
  }
  setRefreshToken(refreshToken) {
    if (typeof window === "undefined") {
      return;
    }
    localStorage.setItem(this.options.refreshTokenKey, refreshToken);
  }
  getRefreshToken() {
    if (typeof window === "undefined") {
      return null;
    }
    return localStorage.getItem(this.options.refreshTokenKey);
  }
  /**
   * Clear the authentication token
   */
  clearToken() {
    if (typeof window === "undefined") {
      return;
    }
    localStorage.removeItem(this.options.tokenStorageKey);
    localStorage.removeItem(this.options.refreshTokenKey);
  }
  /**
   * Redirect to the login page
   */
  redirectToLogin() {
    if (typeof window === "undefined") {
      return;
    }
    const currentPath = encodeURIComponent(window.location.href);
    const separator = this.options.loginUrl.includes("?") ? "&" : "?";
    const fullUrl = `${this.options.loginUrl}${separator}from_url=${currentPath}`;
    const redirectUrl = fullUrl.replace("/api", "");
    window.location.href = redirectUrl;
  }
  /**
   * Check if the user is authenticated
   * This makes an actual API call to verify the token is valid
   */
  async isAuthenticated() {
    try {
      if (this.user) {
        return true;
      }
      const token = this.getToken();
      if (!token) {
        return false;
      }
      await this.validateToken();
      return true;
    } catch (error) {
      return false;
    }
  }
  /**
   * Wait for authentication to be ready
   * This is useful when you need to ensure auth is ready before making requests
   */
  async waitForAuth() {
    if (!this.authPromise) {
      this.authPromise = this.initialize();
    }
    return this.authPromise;
  }
  /**
   * Make an authenticated request to the API
   */
  async request(path, options = {}) {
    if (this.doesCurrentRouteRequireAuth()) {
      await this.waitForAuth();
    }
    if (this.doesCurrentRouteRequireAuth()) {
      if (!await this.isAuthenticated()) {
        this.redirectToLogin();
        throw new Error("Authentication required");
      }
    }
    const token = this.getToken();
    const headers = new Headers(options.headers || {});
    if (token) {
      headers.set("Authorization", `Bearer ${token}`);
    }
    if (this.options.appId) {
      headers.set("X-App-ID", this.options.appId);
    }
    if (typeof window !== "undefined") {
      headers.set("X-Origin-URL", window.location.href);
    }
    const response = await fetch(`${this.options.baseUrl}${path}`, {
      ...options,
      headers
    });
    if (response.status === 401 || response.status === 403) {
      if (this.doesCurrentRouteRequireAuth() && response.status === 401) {
        try {
          await this.refreshToken();
          return this.request(path, options);
        } catch (error) {
          this.redirectToLogin();
          throw new Error("Authentication required");
        }
      }
      throw new Error("Authentication required");
    }
    if (!response.ok) {
      const errorText = await response.text();
      let errorMessage;
      try {
        const errorJson = JSON.parse(errorText);
        errorMessage = errorJson.message || errorJson.error || errorText;
      } catch {
        errorMessage = errorText;
      }
      throw new Error(`API request failed: ${errorMessage}`);
    }
    return await response.json();
  }
  /**
   * Make a GET request to the API with query parameters
   */
  async get(path, options = {}) {
    let finalPath = path;
    if (options.params) {
      const searchParams = new URLSearchParams();
      Object.entries(options.params).forEach(([key, value]) => {
        if (value !== void 0) {
          searchParams.append(key, String(value));
        }
      });
      const queryString = searchParams.toString();
      if (queryString) {
        finalPath += (finalPath.includes("?") ? "&" : "?") + queryString;
      }
    }
    const requestOptions = {
      method: "GET",
      ...options
    };
    delete requestOptions.params;
    return this.request(finalPath, requestOptions);
  }
  /**
   * Make a POST request to the API
   */
  async post(path, body, options = {}) {
    const requestOptions = {
      method: "POST",
      body: body instanceof FormData ? body : JSON.stringify(body),
      ...options
    };
    return this.request(path, requestOptions);
  }
  /**
   * Make a PUT request to the API
   */
  async put(path, body, options = {}) {
    const requestOptions = {
      method: "PUT",
      body: body instanceof FormData ? body : JSON.stringify(body),
      ...options
    };
    if (!(body instanceof FormData) && !options.headers) {
      requestOptions.headers = {
        "Content-Type": "application/json"
      };
    }
    return this.request(path, requestOptions);
  }
  /**
   * Make a DELETE request to the API
   */
  async delete(path, options = {}) {
    const requestOptions = {
      method: "DELETE",
      ...options
    };
    if (options.data) {
      requestOptions.body = JSON.stringify(options.data);
      if (!options.headers) {
        requestOptions.headers = {
          "Content-Type": "application/json"
        };
      }
    }
    delete requestOptions.data;
    return this.request(path, requestOptions);
  }
  /**
   * Get entity manager for a specific entity type
   * @returns EntityManager instance with typed operations
   */
  entity(entityName) {
    if (!this.options.appId) {
      throw new Error("AppId is required to use entity operations");
    }
    const existingManager = this.entityManagers.get(entityName);
    if (existingManager) {
      return existingManager;
    }
    const manager = new EntityManager(this, entityName, this.options.appId);
    this.entityManagers.set(entityName, manager);
    return manager;
  }
  /**
   * Access entities using proxy pattern (for backward compatibility)
   */
  get entities() {
    return new Proxy(
      {},
      {
        get: (_, entityName) => {
          if (typeof entityName !== "string" || entityName.startsWith("_") || entityName === "then") {
            return void 0;
          }
          return this.entity(entityName);
        }
      }
    );
  }
};
function createSuperdevClient(options = {}) {
  const client = new SuperdevClient(options);
  const auth = createAuthModule(client);
  const integrations = createIntegrationsModule(client);
  const functions = createFunctionsModule(client);
  return Object.assign(Object.create(Object.getPrototypeOf(client)), client, {
    auth,
    integrations,
    functions
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ApiClientError,
  EntityManager,
  EntityQuery,
  SuperdevClient,
  createSuperdevClient
});
