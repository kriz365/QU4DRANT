/**
 * Simple authentication module for Superdev applications
 */

interface AuthOptions {
    loginUrl?: string;
    tokenStorageKey?: string;
    refreshTokenKey?: string;
}
declare class AuthModule {
    private client;
    private options;
    private user;
    constructor(client: SuperdevClient, options?: AuthOptions);
    /**
     * Get the current authentication token
     */
    getToken(): string | null;
    /**
     * Set the authentication token
     */
    setToken(token: string): void;
    /**
     * Clear the authentication token
     */
    clearToken(): void;
    /**
     * Redirect to the login page
     */
    login(): void;
    /**
     * Check if the user is authenticated
     */
    isAuthenticated(): Promise<boolean>;
    /**
     * Get the current user
     */
    getUser(): Promise<User | null>;
    /**
     * Get the current user's full profile
     */
    me(): Promise<User>;
    list(options?: QueryOptions): Promise<User[]>;
    /**
     * Update the current user's profile
     */
    updateProfile(data: Partial<User>): Promise<User>;
    /**
     * Log the user out
     */
    logout(redirectToLogin?: boolean): Promise<void>;
}

type PublicIntegrationsModule = {
    [key: string]: {
        [key: string]: (params: any) => Promise<any>;
    };
};
declare const createIntegrationsModule: (client: SuperdevClient) => PublicIntegrationsModule;

type PublicFunctionsModule = {
    [key: string]: (params?: any) => Promise<any>;
};
declare const createFunctionsModule: (client: SuperdevClient) => PublicFunctionsModule;

/**
 * Superdev Client SDK
 *
 * A lightweight client for interacting with Superdev applications
 * Handles authentication and token management
 */

/**
 * Configuration options for the Superdev client
 */
interface SuperdevClientOptions {
    /**
     * Base URL for API requests (defaults to window.location.origin)
     */
    baseUrl?: string;
    /**
     * Whether authentication is required
     * - true: Requires auth for all routes
     * - false: No auth required for any routes
     * - string[]: Array of route patterns that require authentication
     */
    requiresAuth?: boolean | string[];
    /**
     * Storage key for the access token
     */
    tokenStorageKey?: string;
    /**
     * Storage key for the refresh token
     */
    refreshTokenKey?: string;
    appId?: string;
    /**
     * Custom URL to redirect to for login
     */
    loginUrl?: string;
    /**
     * Custom URL to redirect to for logout
     */
    token?: string;
}
/**
 *
 *  object returned from authentication calls
 */
interface User {
    id: string;
    email?: string;
    full_name?: string;
    picture?: string;
    created_at?: string;
    [key: string]: any;
}
/**
 * Base entity type with required id field
 */
interface Entity {
    id: string;
    [key: string]: any;
}
/**
 * Response for list and filter operations
 */
interface EntityListResponse<T extends Entity> {
    data: T[];
    total: number;
    limit: number;
    skip: number;
}
/**
 * Query options for entity operations
 */
interface QueryOptions {
    sort?: string | Record<string, 1 | -1>;
    limit?: number;
    skip?: number;
    fields?: string | string[];
    select?: string | string[];
    populate?: string | string[] | Record<string, any>;
}
/**
 * Query parameters for filtering
 */
interface FilterQuery {
    [key: string]: any;
}
/**
 * Query builder for entity operations
 */
declare class EntityQuery<T extends Entity> {
    private client;
    private entityName;
    private appId;
    private query;
    private options;
    constructor(client: SuperdevClient, entityName: string, appId: string);
    /**
     * Set fields to select (projection)
     */
    select(fields: string | string[]): EntityQuery<T>;
    /**
     * Set sort order
     */
    sort(sort: string | Record<string, 1 | -1>): EntityQuery<T>;
    /**
     * Set result limit
     */
    limit(limit: number): EntityQuery<T>;
    /**
     * Set number of results to skip (for pagination)
     */
    skip(skip: number): EntityQuery<T>;
    /**
     * Add a where condition
     */
    where(field: string, value: any): EntityQuery<T>;
    /**
     * Add an equals condition
     */
    equals(field: string, value: any): EntityQuery<T>;
    /**
     * Add a not equals condition
     */
    notEquals(field: string, value: any): EntityQuery<T>;
    /**
     * Add a greater than condition
     */
    gt(field: string, value: any): EntityQuery<T>;
    /**
     * Add a greater than or equal condition
     */
    gte(field: string, value: any): EntityQuery<T>;
    /**
     * Add a less than condition
     */
    lt(field: string, value: any): EntityQuery<T>;
    /**
     * Add a less than or equal condition
     */
    lte(field: string, value: any): EntityQuery<T>;
    /**
     * Add an in condition
     */
    in(field: string, values: any[]): EntityQuery<T>;
    /**
     * Add a not in condition
     */
    nin(field: string, values: any[]): EntityQuery<T>;
    /**
     * Execute query and return results
     */
    exec(): Promise<EntityListResponse<T>>;
    /**
     * Count matching documents
     */
    count(): Promise<number>;
    /**
     * Get first matching document
     */
    first(): Promise<T | null>;
}
/**
 * Entity manager for a specific entity type
 */
declare class EntityManager<T extends Entity> {
    private client;
    private entityName;
    private appId;
    private basePath;
    constructor(client: SuperdevClient, entityName: string, appId: string);
    /**
     * Create a new query builder
     */
    query(): EntityQuery<T>;
    /**
     * Find entities matching query
     */
    find(query?: FilterQuery, options?: QueryOptions): EntityQuery<T>;
    /**
     * Find entities with simpler interface (compatible with previous API)
     */
    filter(query: any, sort?: string, limit?: number, skip?: number, fields?: string | string[]): Promise<EntityListResponse<T>>;
    /**
     * List all entities with optional pagination
     */
    list(options?: QueryOptions): Promise<EntityListResponse<T>>;
    /**
     * Get entity by ID
     */
    get(id: string): Promise<T>;
    /**
     * Create new entity
     */
    create(data: Omit<T, "id">): Promise<T>;
    /**
     * Update entity by ID
     */
    update(id: string, data: Partial<T>): Promise<T>;
    /**
     * Delete entity by ID
     */
    delete(id: string): Promise<{
        success: boolean;
    }>;
    /**
     * Delete multiple entities
     */
    deleteMany(ids: string[]): Promise<{
        success: boolean;
        count: number;
    }>;
    /**
     * Create multiple entities in one request
     */
    bulkCreate(data: Omit<T, "id">[]): Promise<{
        success: boolean;
        count: number;
        data: T[];
    }>;
    /**
     * Import entities from a file
     */
    importEntities(file: File): Promise<{
        success: boolean;
        count: number;
    }>;
    /**
     * Batch operations for efficiency
     */
    batch(): {
        /**
         * Create multiple entities
         */
        create: (items: Omit<T, "id">[]) => Promise<{
            success: boolean;
            count: number;
            data: T[];
        }>;
        /**
         * Update multiple entities
         */
        update: (updates: Array<{
            id: string;
            data: Partial<T>;
        }>) => Promise<{
            success: boolean;
            count: number;
        }>;
        /**
         * Delete multiple entities
         */
        delete: (ids: string[]) => Promise<{
            success: boolean;
            count: number;
        }>;
    };
}
/**
 * Custom Error class for API Client
 */
declare class ApiClientError extends Error {
    status?: number;
    code?: string;
    data?: any;
    originalError?: any;
    constructor(message: string, status?: number, code?: string, data?: any, originalError?: any);
}
/**
 * Main Superdev client class
 */
declare class SuperdevClient {
    token: string | null;
    private options;
    baseUrl: string;
    appId: string;
    private user;
    private isInitialized;
    private entityManagers;
    private authPromise;
    private routeChangeListenersAdded;
    /**
     * Create a new Superdev client
     */
    constructor(options?: SuperdevClientOptions);
    /**
     * Check if a path matches a pattern
     * @param pattern The pattern to match against (e.g., '/users/:id', '/admin/*')
     * @param path The actual path to check
     * @returns Whether the path matches the pattern
     */
    private matchPath;
    /**
     * Check if the current route requires authentication
     * @returns Whether authentication is required for the current route
     */
    private doesCurrentRouteRequireAuth;
    /**
     * Initialize the client
     * - Reads token from storage
     * - Sets up token refresh
     * - Handles redirects for authentication
     */
    private initialize;
    /**
     * Setup listeners for route changes in SPAs
     * This allows us to check authentication on client-side navigation
     */
    private setupRouteChangeListeners;
    /**
     * Handle a detected route change in SPAs
     */
    private handleRouteChange;
    /**
     * Validate the current token and get user information
     */
    private validateToken;
    /**
     * Refresh the authentication token
     */
    private refreshToken;
    /**
     * Get the current authentication token
     */
    getToken(): string | null;
    /**
     * Set the authentication token
     */
    setToken(token: string): void;
    setRefreshToken(refreshToken: string): void;
    getRefreshToken(): string | null;
    /**
     * Clear the authentication token
     */
    clearToken(): void;
    /**
     * Redirect to the login page
     */
    redirectToLogin(): void;
    /**
     * Check if the user is authenticated
     * This makes an actual API call to verify the token is valid
     */
    isAuthenticated(): Promise<boolean>;
    /**
     * Wait for authentication to be ready
     * This is useful when you need to ensure auth is ready before making requests
     */
    waitForAuth(): Promise<void>;
    /**
     * Make an authenticated request to the API
     */
    request<T>(path: string, options?: RequestInit): Promise<T>;
    /**
     * Make a GET request to the API with query parameters
     */
    get<T>(path: string, options?: {
        params?: Record<string, any>;
    }): Promise<T>;
    /**
     * Make a POST request to the API
     */
    post<T>(path: string, body: any, options?: RequestInit): Promise<T>;
    /**
     * Make a PUT request to the API
     */
    put<T>(path: string, body: any, options?: RequestInit): Promise<T>;
    /**
     * Make a DELETE request to the API
     */
    delete<T>(path: string, options?: RequestInit & {
        data?: any;
    }): Promise<T>;
    /**
     * Get entity manager for a specific entity type
     * @returns EntityManager instance with typed operations
     */
    entity<T extends Entity = Entity>(entityName: string): EntityManager<T>;
    /**
     * Access entities using proxy pattern (for backward compatibility)
     */
    get entities(): Record<string, EntityManager<Entity>>;
}
/**
 * Create a new Superdev client
 */
type PublicSuperdevClient = SuperdevClient & {
    auth: AuthModule;
    integrations: ReturnType<typeof createIntegrationsModule>;
    functions: ReturnType<typeof createFunctionsModule>;
};
declare function createSuperdevClient(options?: SuperdevClientOptions): PublicSuperdevClient;

export { ApiClientError, type Entity, type EntityListResponse, EntityManager, EntityQuery, type FilterQuery, type QueryOptions, SuperdevClient, type SuperdevClientOptions, type User, createSuperdevClient };
